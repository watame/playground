# マイヤーズの三角形問題
テストの奥深さを語る有名な問題のこと。

```
• このプログラムは、カードから3つの整数を読む
• この3つの値は、それぞれ三角形の3辺の長さをあらわすものとする
• このプログラムは、三角形が、不等辺三角形・二等辺三角形・正三角形のうちどれであるかを決めるメッセージを印字する
このプログラムをテストするのに十分と思われる一連のテストケース（すなわち、十分なデータのセット）を、紙に書き記してみよ。
```

単純なプログラムだが、14パターンのテストケースが考えられる。
-> テストパターンが14個なので、テストケースはもっとある！！

機能の単純さがテストの単純さではない。
-> **大事なのは、「一つひとつのテストケースに、それぞれ意味や意図がある」こと**

テストとは、

- 何を
- 何のために
- どんなテストを行うのか

を考えることが重要で、そのために用意周到に計画し、設計して、導き出す必要がある

## URI
- https://www.qbook.jp/academy/curriculum/0001/lessons/ad00001/

# ソフトウェアテストとは、テストエンジニアの役割とは
## ソフトウェアとは何か
- 機械に対する人間からの指令を組み立てたもの

例：Webブラウザ
• ユーザーが、閲覧したいインターネット上のURL（サイト）にアクセスする
• そのURL（サイト）にある文章や画像ファイルを読み込む
• WEBブラウザのウインドウ上に、それらの情報を表示する

近年は身の回りにある様々な製品の内部にソフトウェアが組み込まれている。

## ソフトウェアテストの必要性
前提：**人が作ったものに完璧はあり得ない**

ソフトウェアの開発は、開発エンジニアが行う。
-> どれだけ慎重に作成しても全て完璧というわけではない -> 考慮漏れやミスなどの**バグ**が必ず紛れ込んでいる

バグは軽微なもの（表示のズレ）から重大なもの（プログラムのクラッシュ）など多様。
-> 些細なバグも許されないソフトウェアでバグが頻発すれば、最悪人命に関わる

ソフトウェアが使用どおりに動作するか確認し、検出されたバグを修正する工程が必要
-> この確認工程のことを**ソフトウェアテスト**という

## ソフトウェアテストの目的
主目的は2つ
1. 製品が仕様や要求を満たしていることを確認する
2. バグを検出し、それが正しく修正されたことを確認する

他の目的
- ソフトウェアの品質がどの程度成熟しているかを判断するための情報を得る
  - テストによってバグの数や存在数カ所が把握でき、品質状況が見えてくる
  - **ソフトウェアの品質がどの程度成熟したのか、定量的に判断できるようになる**
- バグ傾向を捉えることで、改善活動につなげる
  - テストで見つけたバグ傾向を分析することで、ソフトウェア品質の改善につながる改善ができる

**ソフトウェアのテストは、仕様どおりに動くことを確認するだけではない！**

## 開発エンジニアとテストエンジニアの役割
共通の目的：高品質な製品を世の中に送り出す
開発エンジニアの目的：どうしたら適切に**開発**できるか
-> 「仕様を満たすソフトウェアをどのように設計するか」を主に視野に入れる
QAエンジニアの目的：どうしたら適切に**テスト**できるか
-> 「そもそも仕様に曖昧な点や矛盾点がないか」「どうしたら仕様や要求を満たしていると適切に確認できるか」「どうしたら漏れなくテストできるか」「どうしたらバグを検出できる可能性が高まるか」ということを主に視野に入れる

## URI
- https://www.qbook.jp/academy/curriculum/0001/lessons/ad00002/

# テストの種類
## 単体テスト・結合テスト・システムテスト
プログラムは下記の組み合わせで出来ている。
```
関　　数：プログラムの部品の最小単位
機　　能：「関数」を組み合わせて作り上げたもの
システム：「機能」を組み合わせて作り上げたもの

プログラム単位の大小関係
　関数 < 機能 < システム
```

ソフトウェアテストは**小さな単位から始めて、粒度を大きくしていく**。

＜テストの順序＞
1.（粒度小）プログラムの最小単位である「関数」を対象に、「単体テスト」を行う
2.（粒度中）いくつかの関数を組み合わせて、「結合テスト」を行う
3.（粒度大）いくつかの機能を組み合わせて、「システムテスト」を行う

＜粒度を、小さな単位からだんだん大きくする理由＞
・テスト対象の粒度が大きくなるほど、プログラム上で未検証の部分が増えていくため
・テスト対象の粒度が大きくなるほど、バグを見つけにくくなるため
・テスト対象の粒度が大きくなるほど、テストでバグを見つけられても、原因調査がやりにくくなり、工数がかかるため
・テスト対象の粒度が大きくなるほど、手戻りが大きくなり、コスト的にも時間的にも無駄が生じるため

粒度の違いのことを**テストレベル**というので、覚えておこう。

## 機能テスト、非機能テスト
＜機能テスト＞
定義されている機能が仕様どおりに動作するかを、検証するテスト
-> 「機能要件」を満たすもの
    機能要件：どんな機能を持たせる必要があるか定義するもの

＜非機能テスト＞
機能テストの項目以外を検証するテスト
-> 「非機能要件」を満たすもの
    非機能要件：機能には直接関係しないものの、そのソフトウェアやシステムが備えるべき特性
テスト例：
・性能テスト
・信頼性テスト（大容量テスト、エージングテストなど）
・ユーザビリティテスト　　など

## ホワイトボックステスト、ブラックボックステスト
＜ホワイトボックステスト＞
テスト対象のプログラム構造を把握した上で行うテスト
-> プログラムが設計した通りに、実装した通りに動作するかを確認する
    **プログラムに漏れがあった場合には、バグを検知できない**

＜ブラックボックステスト＞
入力から出力が想定どおり動くかを確認するテスト
-> テスト対象のプログラムの構造を把握していない状態で、使用どおりに動作するかを確認する
    **プログラムのロジックバグは検知できない**

テストレベルで使い分けると以下。
- 単体テスト：ホワイトボックステスト
- 結合テスト：ホワイトボックステスト
- システムテスト：ブラックボックステスト

## 検証と妥当性確認（V&V）
下記の2つの視点を合わせてV＆Vと呼ぶ
- 検証（Verification）：仕様通りに動作するか、製品が正しく動作するかを確認すること
- 妥当性の確認（Validation）：その製品によって目的を達成できているか、正しい製品を開発できているかを確認すること

2つの視点がある理由
-> 検証の視点でテストを実施してバグがゼロでも、妥当でなければ品質が高いとは言い切れない
    例：使用通りの動きをするけど、めちゃくちゃUIが使いにくい

テスト経過計画の早期段階で明確にしておくことが必要
-> **視点のいずれかが欠けてしまった場合、大きな手戻りや作業追加が発生する！**

## 動的テスト、静的テスト
＜動的テスト＞
プログラムやシステムを実際に動かして検証すること

＜静的テスト＞
プログラムやシステムを動かさずに検証すること
テスト例：
・コードレビュー
・静的解析
メリット；
・動的テストで再現するのは困難な、微妙なタイミングなどで発露するバグを、比較的見つけやすい
・動的テストは、バグの発見から修正まで、バグ票の起票と原因解析を行うことで時間と労力がかかる。それに対して、静的テストのレビューなどでは、不具合箇所をピンポイントで見つけられるため、コストを抑えて対処しやすい。

## 手動テスト、自動テスト
＜手動テスト＞
テストオペレーションを人の手で行うこと

＜自動テスト＞
テストオペレーションをコンピュータで行うこと
メリット：
・テストのオペレーションが迅速で正確（誤操作・誤認識などのヒューマンエラーが無い）
・繰り返し何度も実施することでコスト的なメリットが得られる
自動テスト導入・運用に必要な条件：
・テスト対象が自動テストを実施できる構造になっていること
・自動テストの環境を開発し、セットアップするコストと労力がかかること
・仕様変更・設計変更が生じたら、それを自動テスト環境にも反映する必要があること

## スクリプト型テスト、非スクリプト型テスト
＜スクリプト型テスト＞
テストオペレータがテスト手順書を参照しながら、テストの操作を実施する
-> 自動テストもこの一種
メリット：
・テスト設計の質を担保しやすい
・テスト設計の内容を文書化すれば、レビューしやすい
・テストの再利用がしやすい

＜非スクリプト型テスト＞
テストの実施手順を定めず、テストの操作を実施する
テスト例：
・モンキーテスト
・探索的テスト（テストの熟練者が仕様の把握とテスト対象の動きを観察しながら行うテスト）
メリット：
・テスト設計の手間を省けるため、テスト期間を短縮できる
・テスト内容を臨機応変に変えられる

## URI
- https://www.qbook.jp/academy/curriculum/0001/lessons/ad00003/

# テスト設計とは
効果的で効率的なソフトウェアテストを実施するためには、テスト対象とテイスト方法を明確にすることが必要不可欠。
-> この定義を行うことを「テスト設計」という

## なぜテスト設計が必要なのか
最終成果物であるテストケースを作るため
- テストケース：
    - テストオペレータがテスト実施時に用いる手順書のこと
    - テスト対象を
        - どんな状態にして
        - どんな操作をして
        - どんな確認をするか
    - を定義する

テストケースは機能仕様書から**直接作成せず**、中間成果物を作りながら設計して作成する。
-> 中間成果物を作りながら設計することを「段階的詳細化」と言う

段階詳細化のメリットは下記
- 抜け漏れの無いテストケースが生成でき、ひいてはバグを見逃す可能性を低くできる
- より細かいところに突っ込んだテストケースを生成し、バグを検出する可能性を高められる
- テストケースの数を必要最少に抑え、コスト・時間の両面で最適化が図れる

## 段階詳細化の考え方
1. 最初はテスト対象を大きく捉え、テストすべき観点を考える。
2. 次に観点を少しづつ深掘りしていきながら、テストケースを具体的にしていく。

この考え方は地図を使う際のプロセスに似ている。
1. 地図で出発地と目的地を決める
2. 考えられるルートを検討する
    - 有料道路？
    - 一般道路？
    - 有料・一般混合？
3. ルートのうち最適なルートに対し、さらに詳細に考えていく
    - 新しい道ができていない？
    - 定期的にコンビニに立ち寄る？

## テスト設計プロセス
テスト設計のプロセスは以下。
1. テスト対象の分析プロセス
2. テスト基本設計プロセス
3. テスト詳細設計プロセス
4. テスト実装プロセス

### 1. テスト対象の分析プロセス
- 目的
    - テスト対象のシステム仕様や要求を分析すること
- 活動
    - 機能仕様書等の読み込み
        - 仕様書や画面設計書などの情報源をまとめて「テストベース」と呼び、テスト分析の対象とする
        - 仕様を把握するだけではなく、**要求に沿った仕様となっているか**もチェック
    - 下記の観点から、テスト対象の洗い出しを行う
        - 「何」に対し、どんなテストが必要か
        - 機能仕様書等で定義すべきものに抜け漏れ・曖昧な箇所・矛盾した箇所がないか

テストベースは大きく分けて以下の4種類がある

#### 1. 要求（要件）仕様
要求仕様はビジネス要求・システム要求の仕様書
-> 要求仕様署、要件仕様書、ユースケース、ユーザーストーリー、プロダクトバックログなど
    システムやソフトウェアに対して、期待されている機能要件や非機能要件が記載されている情報源が対象となる

大切なことは、**「なぜ」要求がされているか、「誰」のための要件か、要件が設定されている理由や背景を理解すること**。
-> テスト対象の利用シーンの想定につながり、テスト設計に活かせる

#### 2. 設計仕様
システム設計仕様書
-> 機能仕様書・アーキテクチャ構成図、ER図、CRUD図、DB設計資料、画面仕様書、IF仕様書、クラス図、シーケンス図など

システムをどのように構築するかを具体的にまとめたものが対象となる。

#### 3. 実装したシステムやプログラム
実装作業を行なったプログラム
-> ソースコード・SQLなど

#### 4. プロダクトリスク分析結果
システムの機能面・非機能面などのリスクを分析した結果
-> リスクをもとにテスト活動を推進する「リスクベースドテスト」を行うための資料

#### テスト分析の内容
下記の作業を実施する。
- テストベースの分析と不明点の整理
    - 抜け漏れ・曖昧な箇所を明らかにする
        - 資料作成者へのヒアリングを行う
        - 実際にプログラムを動作させてみる
- テスト対象機能の抽出と整理
    - テストすべき機能、テストしない機能を明確にする
        - テストしやすいようにキノや要素を細分化する
        - 機能面、非機能面の特性、ビジネス面、技術面の要因
    - 分析の際には不明確な点は表や図にまとめ、わかりやすく網羅的に整理していく
        - デシジョンテーブル・状態遷移図などを用いると良い

テスト分析作業中、使用上の結果を検出することは多い
-> システムの仕様をテスト可能な形で整理することで、仕様の曖昧な点が発見できる

#### テスト分析の進め方
テスト設計作業と並行して進められることも多い
-> 「何をテストするのか」「どのようにテストするのか」は密接に関わるため、単独でやるように効果的にできるため

テスト対象/非対象の整理は、テスト工数の見積もり・スケジュール策定作業に大きく影響する。
-> テスト計画の段階では詳細まで詰めなくても良いが、あとで詳細なテスト分析を行うことは欠かせない

#### URL
- https://www.qbook.jp/academy/curriculum/0003/lessons/ad00008/

### 2. テスト基本設計プロセス
「そのシステム（機能）には、どんなテストが必要か」レベルで、テスト全体の指針を決めていく。
-> テストデータに使うデータや環境はどんなものが必要か、概要を検討する

**この段階では、テストオペレータがテストを実施する際のテストケースは作成しない**
-> テストケースには、テスト対象を「最初にどんな状態にし、どんな操作をし、何を確認してOK/NGとするか」を記述する

### 3. テスト詳細設計プロセス
テスト基本設計プロセスの指針を受け継ぎ、より詳細にテストを設計する。
-> テキストボックスの入力チェックで、どのような文字種・文字数でテストするか、レベルまで具体的に詰めていく
    テストに必要なデータや環境についても、詳細を詰める

### 4. テスト実装プロセス
テスト詳細設計プロせるまで検討した内容をもとに、テストケースを作成する。
テストデータの作成、テスト環境のセットアップ、テスト実施の準備も併せて行う。

## テスト設計の成果物
テストケースの生成に至るまで、テスト設計のそれぞれの段階で、テスト設計の中間成果物を生成する。
-> 中間成果物がテストドキュメントとなる
    テストドキュメントはテストの理由が明確になっているため、非常に役立つ
    機能仕様書とテストケースの整合性も取れ、漏れなくテストケースを生成できる

## テスト設計の目的
大きく以下の3つ
1. 抜け漏れのないテストケースの生成
2. バグ検出の可能性が高いテストケースの生成
3. より項目数が少ないテストケースの生成

-> **抜け漏れがなく網羅性の高いバグが発見しやすいテストを、より少ない件数のテストケースで実現する** ことが目的

上記の目的を達成するテストケースを、機能仕様書などから直接生成することは非常に困難
-> 機能仕様書から直接コーディングすると、プログラム全体が歪になることと同じ

テスト設計について、もうちょっと知りたかったら「QUINTEE（クインティ）」テスト設計メソッドをみよう。
