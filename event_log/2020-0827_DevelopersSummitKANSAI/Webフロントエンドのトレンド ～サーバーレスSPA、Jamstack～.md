# ヘッドレス CMS

- microCMS

## Web サイトと Web アプリケーションの違い

### Web アプリケーション

- 目的
  - サービスの提供
- 手段
  - ユーザのやりたいことを実現する
- 必要条件
  - 複雑な機能要求に耐えられる

### Web アプリケーション

- 目的
  - マーケティング
- 手段
  - ユーザの欲しい情報を発信する
- 必要条件
  - 検索エンジンフレンドリーである
  - 編集者がコンテンツを編集できる
    -> 目的が違うので、作り方も大きく違う

## Web アプリケーション構築の歴史

大きな転機

1. Ajax の登場
   1. SPA への大きな布石
   2. 非同期通信を Web アプリに用いる事ができるようになった
      1. 例：GoogleMap
   3. ページ遷移のたびに毎回 HTML を戻すのは遅いので、必要なデータだけ都度 Ajax で取得する
   4. SPA につながる
2. モジュールシステムの登場
   1. クライアントサイドでの大規模アプリができる

# MVC 設計の導入

jQuery だけでは SPA の状態管理に HRML の Hidden 等に埋め込むのは辛い
→ サーバサイドのフレームワークに倣い、クライアントサイドでも MVC 設計を導入する流れが出てきた
→→ JavaScript フレームワークが出てきた

# フレームワークを導入しても SPA は複雑

当時のクライアント再度にはモジュールシステムがなかったので、処理の分割がしづらい
グローバルな名前空間でモジュールを利用する
→ 読込順によってバグが発生する

# 2.モジュールシステムの登場

Node.js 側のモジュールがクライアントでも利用でき、依存関係が整理できるようになった

## Flux の登場

MVC のスケールしない問題を解決する（Model と Controller が密結合になる）
→ 処理の流れを一方通行にすることでスケールしやすくした

## SPA の問題点

- SEO が弱い
  - 動的にコンテンツを生成するので、検索に載りにくい
  - つまり、クローラによっては、インデックスされない可能性がある
- 初期ロードが遅い
  - バンドルされた JS を読み込む時間がかかる

## SSR(サーバサイドレンダリング)と組み合わせて解決

- 初期ロードだけは SSR にして、遷移以降は SPA の挙動をする
- SEO やロード時間が解決できるが、実装難易度が高い

## Next/Nuxt の登場

- ファイルシステムに基づいたルーティング
  - ディレクトリ構造がそのままページ URI になる
- SSR 処理の大半をフレームワーク側が担ってくれる
- 複雑な WebPack や Babel の設定をフレームワークがやってくれる

## そもそも SSR 必要？

そんなに必要なケースないのでは。

- SEO
  - サービスを提供するのなら、検索に引っかかる必要ない
  - ランディングページ（説明ページ）のみ SPA 外で配信すれば SEO にも載る
- バンドル JS が重い場合も、キャッシュされれば気にならない

## サーバレス SPA という選択肢

- SPA は index.html とバンドル JS さえあれば動く
- サーバー再度で行う処理は API を通じてやれば OK では

### サーバレスのメリット

- サーバがないので管理不要
- スケールしやすい
- セキュア
  - API をたたくのみなので、API の OS は AWS に任せられる
  - アプリ側のセキュリティに注力できる
  - セキュリティチェックも AWS 任せにできるので、自社管理よりもらくちん

# Web サイトの構築手法

- SEO が重要なので静的サイトメイン
- 基本は HTML/CSS
- 動きのためだけに jQuery
- 管理画面から編集できるようにする（WordPress 等）
  -> 日本の WordPress シェアは圧倒的

# Web アプリとの溝が広がるわけ

- SEO が重要
- サイト規模が小さいので、フレームワーク等の管理を考える必要なし
- 非エンジニアが編集可能である必要がある（CMS）

# 溝を埋めるには

## SSG(静的サイト生成手法)

- HTML を事前に生成する手法
- React などのライブラリを Web サイト制作にも利用できるようになった

## ヘッドレス CMS の登場

- View のついていない CMS
  - CMS 上では画面確認できないが、API で画面情報を取得できる
- リッチな GUI で操作でき、API も標準装備な DB のようなもの
  - React や Vue などで管理画面を利用できる

### ヘッドレス CMS のメリット

- View がないので、編集画面が自由にできる
- コンテンツを API で取得できるから、HTTP 通信できればどこでも利用できる
- 高速なサイトを実現できる
  - Jamstack を利用する

## Jamstack

事前に生成された HTML を CSN から配信することで、高速でセキュアなサイトを実現

- SSG + CSR(クライアントサイドレンダリング)のハイブリッドアーキテクチャ
- 初期ページは事前ビルドした静的ファイルをロードし、ページ遷移時は CSR を行う
- メディア、コーポレートサイトなどに利用されやすい

## プリフェッチによるページ遷移の高速化

- ブラウザキャッシュしていない、リンク先のファイルを事前に取得する
  - スクロールのタイミングで、次のページが取得できる

### JamStack のメリット

- 必要なのは静的ファイルのホスティングだけ
- API コールはビルド時のみ
  - 静的ページを作成するタイミングでだけ API を呼ぶ
  - API リクエストの数が制限されていても安心
- セキュア＆ハイパフォーマンス＆安い

### デメリット

- ページ全体をビルドするので、ページ数が多いとビルドに毎回時間がかかる
- プレビューの実装を自前で作成する必要がある
  - 開発に時間がかかる
- 知見少ない

### JamStack はビルドが 9 割

- 出来る限りの処理をビルド時に行う
  - ビルドの精度でレンダリングの時間が変わる

## Next.js の Incremental Static Regeneration

- SSR/SSG/CSR のハイブリッド
  - 初回アクセス時は SSR
  - 誰かが一度でもアクセスすれば、そのタイミングで SSG
  - 遷移時は CSR
- 利用には Vercel が必要
  - サーバサイド処理も動作する
  - 必要最低限な箇所を SSR して、可能な限り SSG で済ます

## Gatsby の Inremental Builds

- Cloud 上で差分ビルドを行える
- 初回は時間かかるけど、2 回目は高速

# Web フロントエンドのトレンド総評

- Web サイト制作という観点では Jamstack の登場で大きな変化が来ている
  - JavaScript が少しわかればできる？
- Web アプリケーション開発においては大きな変化はないかと
  - Redux→Hooks など
- Rust のフロントエンド実装が流行ってくると変わりそうだけどどうか

# まとめ

- Jamstack で溝は埋まりつつある
- Web アプリケーションは多くの場合、SPA で問題なし
